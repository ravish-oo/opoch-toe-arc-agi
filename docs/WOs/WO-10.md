WO-10 — this is the pass where locally “plausible” laws get proved globally exact or pruned with a single pixel witness. Pure algebra, zero vibes.

---

# WO-10 — Class pullback & Sieve (global exactness, deterministic)

## Purpose

1. Build a **class_map** for each training pair that tells, for every **output** pixel, which **test truth-class** it belongs to.
2. Run a **deterministic sieve** that prunes any class law (KEEP or VALUE) that disagrees with **any** training output pixel.
3. If a class loses all candidates, emit a **constructive certificate** `missing_descriptor` with pixel witnesses. Otherwise, pick the **least** remaining law per class (fixed cost order).

**Debugging = algebra**: every removal logs the **first counterexample**; no skipped tests, no heuristics.

## Files

* `src/class_map.py` (new)
* `src/sieve.py` (new)
* uses: `src/morphisms.py` (WO-01), `src/truth.py` Partition (WO-06), `src/laws/keep.py` (WO-08), `src/laws/value.py` (WO-09), `src/receipts.py` (WO-00)

> Shape law is **not** needed for training proofs here. We work entirely in frames (Π). Shape is used later in test paint (WO-11).

---

## Inputs

* `part: Partition` — truth partition (Q) on **presented test input** (WO-06).
* Frames from Π (WO-02): `P_test`, `P_out[i]`, `P_in[i]`.
* Presented grids: `Xin[i]` (posed+anchored), `Yout[i]` (posed-only), `Xtest`.
* Per-class **admitted** candidates from WO-08 (KEEP) and WO-09 (VALUE).

---

## A) Class pullback (OUT → TEST → class id)

### API

```python
# src/class_map.py
from typing import Dict, List, Optional, Tuple

Coord = Tuple[int,int]

def build_class_map_i(
    H_out: int, W_out: int,
    P_test, P_out_i,
    part # Partition on TEST frame
) -> List[Optional[int]]:
    """
    Returns a row-major array of length H_out*W_out:
      class_id if this output pixel maps to a TEST pixel in-bounds,
      None if OUT→TEST lands OOB.
    Deterministic, pure.
    """
```

### Mapping (frozen algebra)

For each output pixel `p_out = (r,c)`:

```
q = pose_inv(p_out, P_out_i.op, P_out_i.shape)   # OUT → TEST pose-only inverse
q = anchor_fwd(q, P_test.anchor)                 # undo test anchoring direction used in Π
q = pose_fwd(q, P_test.op, P_test.shape)         # TEST posed frame
if q in-bounds:
    cid = part.cid_of[row_major(q)]
else:
    cid = None
```

(Exactly the inverse sequence of TEST→OUT from WO-01.)

**Note:** No shape law here. We only need to know “which test class would own this output pixel if seen in the test frame.”

### Receipt (part of `"selection"` or a small `"class_map"` section)

You don’t need a separate section. When `ARC_SELF_CHECK=1`, you can log a tiny sample:

```json
"class_map_debug": {
  "i": 0, "samples": [ {"p_out":[0,0],"p_test":[t0,t1],"cid":7}, ... ]
}
```

This is optional; sieve receipts (below) will include full witnesses anyway.

---

## B) Sieve (prune to globally exact laws)

### Cost order (fixed, same as earlier)

```
KEEP:tile_alt_* ≺ KEEP:tile ≺ KEEP:d4_* ≺ KEEP:identity ≺
RECOLOR ≺ BLOCK ≺ ARGMAX ≺ UNIQUE ≺ LOWEST_UNUSED ≺ CONST
```

(Exact strings; stable tie-break lexicographic on descriptor text.)

### API

```python
# src/sieve.py
from typing import Dict, List, Tuple, Any, Optional

def run_sieve(
    part,                        # Partition on TEST
    class_maps: List[List[Optional[int]]],  # per-train, row-major class_id or None
    Xin: List[List[List[int]]],  # posed+anchored inputs (for VALUE/RECOLOR evaluation if needed)
    Yout: List[List[List[int]]], # posed-only outputs
    P_test, P_in_list, P_out_list,
    keep_admitted: Dict[int, List[Dict[str,Any]]],   # cid -> list of KEEP descriptors (from WO-08)
    value_admitted: Dict[int, List[Dict[str,Any]]]   # cid -> list of VALUE descriptors (from WO-09)
) -> Dict[str, Any]:
    """
    Returns {
      "exact": True/False,
      "assignment": { cid: "descriptor", ... }   # if exact
      "missing_descriptor": [ { "cid": cid, "examples": [ witness, ... ] }, ... ],  # if not exact
      "prune_log": [ { "cid":cid, "descriptor":str, "train_idx":i, "p_out":[r,c], "expected":y, "got":x, "path": {...} }, ... ]
    }
    Deterministic pass order; stops only when stable or a class empties.
    """
```

### Source evaluator (uniform for KEEP and VALUE)

Implement a tiny internal evaluator so both KEEP and VALUE descriptors can be checked on any `p_out`:

* For **KEEP**: reuse WO-08 mapping:
  `p_out → pose_inv (OUT→TEST) → V_test(p_test) → anchor_fwd → pose_fwd → p_in` → compare `Xin[i][p_in]` to `Yout[i][p_out]`. If `V_test` undefined → **treat as mismatch** (KEEP must be total on observed pixels).
* For **VALUE**:

  * **CONST(c)**: write `c`.
  * **Reducers**: use precomputed `c` per class (from WO-09 admissibility); just write `c`.
  * **RECOLOR(π)**: compute `cin` as above (`p_test → test_to_in → p_in`), write `π(cin)`.
  * **BLOCK(k)**: recompute relative base at class anchor (same as WO-09) using `p_test`, write derived `c`.

All of these **must** match `Yout[i][p_out]` for the law to remain viable.

### Deterministic pass order (frozen)

Outer loop follows a single, predictable iteration order:

```
for i in range(num_trains):                        # train index ascending
  for r in range(H_out[i]):                        # row-major pixels
    for c in range(W_out[i]):
      cid = class_map_i[r,c]
      if cid is None: continue
      # Evaluate in a fixed law order on this cid:
      for law in candidates[cid] in lex order of descriptor:
          if eval(law, i, (r,c)) != Yout[i][r,c]:
              prune(law)  # record first witness and remove from set
# Repeat passes until no pruning occurs in a full pass.
```

**Stop conditions**

* If **no law** remains for some `cid`, **halt** and return:

  ```json
  {"exact": false, "missing_descriptor": [{"cid": cid, "examples": [w1, w2]}]}
  ```

  where each `w` includes `{train_idx, p_out, expected, got}` and a **coordinate path** `{p_test, p_in}` for KEEP/RECOLOR/BLOCK so the implementer can reproduce.
* Otherwise, when a full pass prunes nothing, we are **stable**.

### Final selection

For each cid, pick the remaining law with the **minimal cost** under the cost order. If still tied (identical cost family), choose lexicographically smallest descriptor text. This yields:

```json
{"exact": true, "assignment": {"7": "RECOLOR(pi={2:6,3:1})", ...}}
```

---

## Receipts (merge into `"selection"`)

Emit one `"selection"` section per task:

```json
{
  "status": "exact" | "missing_descriptor",
  "assignment": { "7": "KEEP:tile_alt_row_flip", "9": "CONST(c=2)" },
  "cost_order": ["KEEP:tile_alt_*","KEEP:tile","KEEP:d4_*","KEEP:identity","RECOLOR","BLOCK","ARGMAX","UNIQUE","LOWEST_UNUSED","CONST"],
  "prune_log": [
    { "cid":7, "descriptor":"KEEP:identity", "train_idx":0, "p_out":[1,4],
      "expected":6, "got":3,
      "path": { "p_test":[1,4], "p_test_after_V":[1,4], "p_in":[1,4] } }
  ],
  "missing": [
    { "cid":12, "examples": [
        { "train_idx":1, "p_out":[2,7], "expected":5, "got":2,
          "path": { "p_test":[...], "p_in":[...] } }
    ]}
  ]
}
```

* `prune_log` records the **first** witness per (cid, descriptor). Deterministic order.
* If `status="missing_descriptor"`, `assignment` may be omitted or partial; `missing` must list at least one example per empty class.

Log with `receipts.log("selection", payload)`.

---

## Built-in self-check (debugging = algebra)

Guarded by `ARC_SELF_CHECK=1`, add `_self_check_sieve()` that runs after building class_maps on synthetic fixtures:

1. **Identity vs Tile paradox**
   Build a case where identity matches some pixels but fails on flipped rows; tile_alt_row_flip matches all. Expect sieve to prune identity and keep tile_alt_row_flip; selection exact. If not, record witness and raise `"sieve paradox not resolved"`.

2. **KEEP vs RECOLOR**
   Case where both seem plausible locally but RECOLOR fails on one train due to π coverage; sieve should prune RECOLOR with a π-coverage witness and keep KEEP (or vice versa if the opposite is true). If not, raise `"sieve recolor coverage failed"`.

3. **Missing descriptor certificate**
   Craft a class where the catalogue intentionally lacks a needed law (e.g., a special BLOCK(k)=4 if you only enumerated {2,3}). Expect `status="missing_descriptor"` with examples. If not, raise `"missing_descriptor not detected"`.

4. **Determinism**
   Run sieve twice; ensure identical `assignment` and identical `prune_log` order (byte-equal JSON). If not, raise `"sieve nondeterministic"`.

On any failure, include the **first** witness in the raised message so Claude can fix algebraically.

---

## Acceptance (implementer)

* `build_class_map_i` returns deterministic class ids or None; no shape law used; pure.
* `run_sieve` prunes deterministically; when stable, either returns `exact` with a full assignment or `missing_descriptor` with witnesses.
* With `ARC_SELF_CHECK=1`, self-check passes.
* Implementer pastes the `"selection"` receipt JSON (showing either exact or missing) for a real task.

---

## Reviewer (after implementation)

* Add tests that:

  * Confirm class_map is the correct inverse of TEST→OUT (use a small toy grid; check a few pixels).
  * Enforce prune order stability; the **same** first witness must be recorded for a known-bad descriptor.
  * Verify the paradox test (identity vs tile) is resolved in favor of the globally exact one.
  * Verify missing descriptor behavior: the run halts with a certificate and does **not** silently pick a wrong law.

---

## Prohibited

* Using training outputs to **define** a predicate or a law; outputs are only for comparisons.
* Non-deterministic traversal or candidate order.
* Skipping a failing test: a single witness is enough to fix; **never bypass**.

---

## How Claude should use receipts to debug (explicit)

1. If a descriptor is pruned, inspect `prune_log` for its **first witness**.
2. Reproduce the mapping for that **one pixel** with the recorded path:

   * For KEEP: `p_out → pose_inv → V_test → anchor_fwd → pose_fwd → p_in` and compare `Xin[i][p_in]` vs `Yout[i][p_out]`.
   * For RECOLOR: compute `cin` and check `π[cin]`.
   * For BLOCK: recompute `base` from class anchor; derive `p_in`.
3. Fix the algebra in the descriptor or accept that the law must be pruned.
4. If a class empties, read `missing_descriptor.examples` and design **exactly one** new descriptor to cover those examples in WO-12.

---

This WO makes the “global exactness” step fully mechanical. By the end, every remaining law is proven across all training pixels, and any gap is a **named, finite** descriptor with concrete pixel witnesses.
