WO-04 will extend S-views with **residue-k periods** and keep the “debugging = algebra” discipline. It plugs straight into your existing `sviews.py` from WO-03. No schema changes needed: we’ll use `views[].meta` and `proof_samples[]` (both already open-ended) for all residue details.

---

# WO-04 — Residue-k Periods (general k, gcd rule, full proof)

## Purpose

Admit **row/column residue-shift views** for **general periods k>1**, proven directly on the presented test grid. This closes mosaic/stripe/weave tasks beyond parity and removes the last ambiguity in S-views.

## Files

* **Modify** `src/sviews.py` (no new modules)
* Uses: `src/morphisms.py` (D4 ops already there), `src/receipts.py`

## Hard rules

* No TODOs, no stubs, no new deps.
* Deterministic enumeration and ordering.
* Residue views admitted **only by full proof** on their domain (no sampling).
* **Closure depth stays 2**; **cap stays ≤128**; same dedup signature as WO-03.
* Input is **presented test input** only (post-Π).

---

## What to add (exactly)

### 1) Minimal exact period per line

Implement two helpers:

```python
def minimal_row_period(G) -> Tuple[int, list]:
    """
    Returns (gcd_row, per_row_periods).
    For each row r, compute the minimal p | W with
      ∀c: G[r][c] == G[r][(c+p) % W].
    If a row is constant, treat its period as 0 (ignored in gcd).
    gcd_row = gcd of all per_row_periods > 0.
    If there are no positive periods or gcd_row == 1, return (1, periods).
    """

def minimal_col_period(G) -> Tuple[int, list]:
    # identical idea for columns (H instead of W).
```

**Determinism/algorithmic details:**

* For each row r, find the **smallest** p dividing W (check divisors of W in ascending order) that satisfies equality.
* “Constant row” means all entries equal; set period[r]=0.
* **gcd_row** is `gcd(period for period>0)`. If no period>0, set gcd_row=1.
* **Exclude** 0s from the gcd.
* Same for columns.

### 2) Admit residue-shift S-views (only when gcd>1)

* If `gcd_row > 1`, admit a **row residue** view:

  * `kind="residue"`, `meta={"axis":"row","p":gcd_row}`
  * Mapping: `V(i,j) = (i, (j + p) % W)`
  * **Domain:** full Ω (all pixels).
  * Proof: check `G[i][j] == G[i][(j+p)%W]` for **all** i,j. Reject if any mismatch.
* If `gcd_col > 1`, admit a **col residue** view:

  * `kind="residue"`, `meta={"axis":"col","p":gcd_col}`
  * Mapping: `V(i,j) = ((i + p) % H, j)`
  * Domain: full Ω; same proof check.

**Why full domain?** If a line’s true period is a **multiple** of gcd, the equality still holds for step `p=gcd`. We only admit when that’s globally true—proof enforces it.

### 3) Deterministic order & integration

* **Insertion order into the base set** (WO-03’s `build_base_views`):
  `identity` → `D4-preserving (op ascending)` → **`residue row (if any)` → `residue col (if any)`** → `translations` (in the bounded lex order from WO-03).
* Dedup signature is unchanged (multiset of (x, V(x)) pairs over domain in row-major). Residue views with the same effect as a translation will dedup deterministically (keep the earlier one by order above).
* Closure and cap rules from WO-03 remain unchanged (depth≤2, ≤128 views total).

---

## Receipts (same `sviews` section, no schema change)

Populate the existing fields:

* `"views"`: include entries like:

  ```json
  {"kind":"residue","dom_size":HW,"meta":{"axis":"row","p":3}}
  ```
* `"proof_samples"`: append one sample per admitted residue view:

  ```json
  {"kind":"residue","ok":true,"checked": HW}
  ```
* `"closure_capped"`: still accurate if the 128 cap truncates after adding residues.

If any proof fails (shouldn’t), include the first counterexample in `"examples"`:

```json
{"kind":"residue","params":{"axis":"row","p":3},"x":[i,j],"gx":v1,"gvx":v2}
```

---

## Built-in self-check (debugging = algebra)

Gate with `ARC_SELF_CHECK=1` (same as WO-03). Add the following to your internal `_self_check_sviews` and run **after** residue integration:

1. **Single-axis period (k=3)**
   Build `G_row3`: each row has period 3 (e.g., repeating `[1,2,3]`) with W multiple of 3; columns arbitrary.
   Expect: admit `{"axis":"row","p":3}`, dom_size=H*W; **do not** admit col residue (unless constant). If mismatch, raise:
   `AssertionError("residue row k=3 failed")` and log counterexample.

2. **Mixed periods with gcd (rows 2 & 4 ⇒ gcd=2)**
   Build `G_mixed`: some rows period 2, some period 4, and some constant.
   Expect: admit row residue `p=2` globally (proof must pass across all rows); **no** column residue. If not, raise:
   `AssertionError("residue gcd rule failed")`.

3. **Incompatible periods (rows 2 & 3 ⇒ gcd=1)**
   Build `G_incompat`: rows with minimal periods 2 and 3.
   Expect: **no** row residue admitted (gcd=1). If a residue is admitted, raise:
   `AssertionError("false-positive residue admitted")`.

4. **Dedup with translations**
   Build `G_tile`: where translating by `dj=p` equals the residue shift `p`.
   Expect: either the residue or the translation remains after dedup, **not both**. Verify that `count` decreases by one after dedup or that only one representative is present and order is stable.

All failures must include `"examples"` with the **first** mismatching coordinate so Claude can fix algebraically.

---

## Acceptance (implementer)

* `build_base_views` now **adds** residue views (when gcd>1) in the exact order specified.
* `build_sviews` returns deterministic S-views; `depth_max ≤ 2`, `count ≤ 128`.
* With `ARC_SELF_CHECK=1`, self-check passes; `"views"` contains residue entries where expected; `"proof_samples"` shows `checked=HW` for residues.

## Reviewer (after implementation)

Write tests that (no malformed inputs):

* On a row-period-3 grid, residue row p=3 is admitted; residue col is not.
* On mixed 2/4 rows, residue row p=2 is admitted; mixed 2/3 rows admit none.
* On a constant grid, both residues are allowed but still pass proof (dom_size=HW).
* Dedup keeps deterministic representative when residue equals a translation.

---

## Prohibited

* Inferring periods from samples; must prove with full domain checks.
* Admitting per-row/per-col residue views with partial domains (v1 admits only global gcd views).
* Changing closure depth or cap.

---

## How receipts keep debugging algebraic

* If PT later over-merges or under-merges mosaics, the `"sviews"` receipt immediately shows whether a residue was admitted, with `p`, `axis`, and `dom_size`.
* A wrong `p` produces a counterexample coordinate in `"examples"`; Claude can reproduce and fix the exact line where equality fails.
* If enumeration order or dedup drifted, the `views` list and `proof_samples` reveal it deterministically.

---

This WO makes residue-k a first-class, **proven** S-view. It removes the parity-only limitation and keeps your S-view basis tight, deterministic, and receipts-visible.
