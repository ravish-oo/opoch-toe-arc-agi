# WO-02 — Projector Π (present / un-present)

## Purpose

Implement the idempotent projector Π and its exact inverse: palette canon (inputs-only), D4 lex pose, anchor for inputs+test, pose-only for outputs. All later steps rely on these commuting identities.

## Files

* `src/present.py`  (new)
* Uses: `src/morphisms.py`, `src/receipts.py`

## Hard rules

* No TODOs, no stubs, no extra deps.
* Pure functions only; the module emits **one** receipt at the end via a self-check.
* Deterministic tie-breaks exactly as below.
* Un-present must be exact inverse of present for inputs and outputs.

## Types

```python
from typing import Dict, Tuple, List, Optional
Coord = Tuple[int,int]
Shape = Tuple[int,int]
Frame = Tuple[int, Tuple[int,int], Shape]   # (d4_op, (dy,dx), (H,W))
PaletteMap = Dict[int,int]                  # old_color -> new_color
```

## Frozen definitions

### Palette canon (inputs-only)

* Build one `PaletteMap` over **all training inputs + test input**.
* Order: sort colors by `(frequency desc, first_appearance_index asc, color_value asc)`.
* Map to `0,1,2,…` in that order.
* Apply to **inputs and test inputs**. For **outputs**, apply the same map where defined; unknown output colors map to themselves.

### D4 lex pose

* Enumerate 8 D4 ops from WO-01.
* For a grid, apply each op, **flatten row-major** to a tuple of ints, pick the minimal tuple. Tie-break by op id (0..7).
* Store op id in the frame.

### Anchor (inputs+test only)

* After palette+pose, find the top-left **non-zero** pixel.
* Anchor `(dy,dx)` shifts that pixel to `(0,0)`. If no non-zero exists, `(0,0)`.
* **Do not anchor outputs.** Outputs are pose-only.

### Frames to record

* `P_test = (op_t, (dy_t,dx_t), (Ht,Wt))`
* For each train pair i:

  * `P_in[i]  = (op_i, (dy_i,dx_i), (H_in[i], W_in[i]))`
  * `P_out[i] = (op_o, (0,0),       (H_out[i], W_out[i]))`  (pose-only)

## API to implement in `present.py`

```python
def build_palette_map(train_inputs: List[List[List[int]]],
                      test_input:   List[List[int]]) -> PaletteMap: ...

def apply_palette(grid: List[List[int]], pm: PaletteMap, outputs_ok: bool=False) -> List[List[int]]:
    """
    outputs_ok=True => unknown colors pass through unchanged.
    else => all colors must be in pm.
    """

def pose_grid(grid: List[List[int]]) -> Tuple[List[List[int]], int]:  # returns posed grid and op id

def anchor_grid(grid: List[List[int]]) -> Tuple[List[List[int]], Tuple[int,int]]:  # returns anchored grid and (dy,dx)

def present_input(grid: List[List[int]]) -> Tuple[List[List[int]], Frame]:
    """Palette→pose→anchor; frame populated with all three."""

def present_output(grid: List[List[int]]) -> Tuple[List[List[int]], Frame]:
    """Palette(pass-through for unknowns)→pose; frame has anchor=(0,0)."""

def unpresent_input(grid: List[List[int]], frame: Frame, pm_inv: PaletteMap) -> List[List[int]]:
    """Exact inverse of present_input; uses morphisms.pose_inv/anchor_inv and inverse palette."""

def unpresent_output(grid: List[List[int]], frame: Frame, pm_inv: PaletteMap) -> List[List[int]]:
    """Exact inverse of present_output; pose_inv + inverse palette."""
```

Notes:

* Provide `pm_inv` by inverting `PaletteMap` (one-to-one by construction).
* Un-present order is the algebraic inverse of present: **anchor_inv → pose_inv → palette_inv** for inputs; **pose_inv → palette_inv** for outputs.

## Algebra to respect

Idempotence on inputs:

```
unpresent_input(present_input(G_in).grid, frame_in, pm_inv) == G_in
```

Idempotence on outputs:

```
unpresent_output(present_output(G_out).grid, frame_out, pm_inv) == G_out
```

Pose identity (already covered in WO-01) must commute with your chosen op id. Anchoring must commute with its inverse.

## Receipts (emit once)

Section: `"present"`
Payload keys:

* `"palette_map_size": int`
* `"palette_first5": List[Tuple[int,int]]`  (first 5 mappings, deterministic order by new_color)
* `"d4_ops": Dict[str,int]`  (e.g., `{"test":op_t, "in_0":op_0, ... , "out_0":op0, ...}`)
* `"anchors": Dict[str,Tuple[int,int]]`  (for inputs + test only)
* `"round_trip_ok_inputs": bool`
* `"round_trip_ok_outputs": bool`
* `"examples"` (only on failure): `{case:"input|output", index?:int, op?:int, anchor?:(dy,dx)}`

Use `receipts.log("present", payload)` once, after the self-check below.

## Built-in self-check (debugging = algebra)

Implement `_self_check_present()` and call it once (module import or `init()`), which:

1. Builds a small palette map on synthetic inputs (mix of 0 and non-zeros) and asserts:

* Map respects frequency, then first appearance, then value.
  If violated, emit receipt with `"examples"` and raise `AssertionError("palette order failed")`.

2. For 4–6 tiny random grids:

* Run `present_input` then `unpresent_input` and assert exact byte equality.
* Run `present_output` then `unpresent_output` and assert exact byte equality.
  On first failure, record a minimal example in `"examples"` and raise with `"present round-trip failed: <case>"`.

3. Determinism spot:

* Run `pose_grid` twice on the same grid; assert same op id.
* Run `anchor_grid` twice; assert same `(dy,dx)`.

Finally log the `"present"` receipt with booleans set accordingly.

Seed any randomness locally (`random.seed(1337)`) and keep the sample sizes small so runs are fast.

## Acceptance (implementer)

* All functions implemented, no TODOs.
* `_self_check_present()` runs and logs `"present"` receipt with both round-trip flags `true`.
* Deterministic under repeated runs.
* Paste the JSON fragment of the `"present"` section in your reply.

## Reviewer (after implementation, per your process)

* Write unit tests that:

  * Fix a seed and verify palette order on crafted multicolor inputs (ties broken exactly as spec).
  * Verify round-trip on 3 real ARC samples (pick any from your corpus).
  * Verify outputs **do not anchor** (i.e., returned frames have `(0,0)` anchors).
  * Negative: mutate one D4 op id returned by `pose_grid` and assert round-trip now fails and the receipt `"examples"` reports `case:"output"`.

No tests for malformed JSON; controlled input only.

## Prohibited

* Any non-deterministic source in palette order or D4 tie-break.
* Anchoring outputs.
* Hidden normalization elsewhere in the codebase.

## How receipts help you debug

* If round-trip fails, `"examples"` gives the minimal failure and which side (input/output) broke.
* If a later module claims “frame slippage,” you can check `"present"` and see the exact op ids and anchors chosen, then reproduce with those frames in WO-01 composites.
* If palette conflicts show up later (e.g., recolor mismatches), `"palette_first5"` lets you confirm both sides used the same canon.

That’s it. This keeps algebraic checks at the boundary, same as WO-01