WO-05 is where we make **components** first-class, in a way that keeps debugging 100% algebraic. We’ll (1) extract 4-connected components per color from the **presented test input**, (2) expose them as **must-link views** that actually merge pixels (by folding to an anchor), and (3) export their masks as **Paige–Tarjan predicates**. Every step has a proof receipt and a built-in self-check with concrete counterexamples on failure.

---

# WO-05 — Components as Must-Link S-views and PT Predicates

## Purpose

Provide color-wise **4-connected components** on the presented test input and make them usable in two places:

1. **Must-link:** as S-views that *actually link* all pixels in a component by mapping every pixel to the component’s anchor.
2. **Paige–Tarjan separators:** as input-only predicates “membership in component k” for deterministic, legal splits.

This closes region-fill, object-wise, and band-by-object tasks without heuristics.

## Files

* `src/components.py` (new)
* modifies call sites later (PT will consume outputs from this module)
* uses: `src/receipts.py`

> We **do not** change your S-views cap/closure. Components live alongside structural S-views, not inside the ≤128 cap.

---

## Frozen definitions (from anchors)

* Grid is **presented test input** (post Π).
* Connectivity is **4-adjacency** (up, down, left, right).
* Components are **per color** (including 0).
* **Anchor of a component:** top-left pixel in the component (min row, then min col).
* Component **mask** is the set of its pixels, stored row-major deterministic order.
* Component **must-link S-view** is **fold-to-anchor**: for x in component, M(x)=anchor; undefined elsewhere.
  Proof obligation: for all x in component, G(M(x))==G(x). True because same color.

---

## API (implement exactly)

```python
from typing import List, Tuple, Dict, Optional, Iterable

Coord = Tuple[int,int]

class Component:
    def __init__(self, color: int, comp_id: int, anchor: Coord,
                 bbox: Tuple[int,int,int,int],   # (top,left,bottom,right) inclusive
                 mask: List[Coord]):             # row-major sorted
        self.color = color
        self.comp_id = comp_id                   # deterministic, see ordering below
        self.anchor = anchor
        self.bbox = bbox
        self.mask = mask                         # no duplicates, sorted

    def contains(self, p: Coord) -> bool:
        # row-major binary search or set lookup (your choice; deterministic)

def build_components(G: List[List[int]]) -> List[Component]:
    """
    Build 4-connected components per color on the PRESENTED test grid.
    Deterministic ordering:
      1) increasing color
      2) then by anchor (row, col)
    Returns a flat list of Component objects in that order.
    """

def component_anchor_views(components: List[Component]) -> List[Dict]:
    """
    Produce must-link S-views that actually merge pixels:
    Each view descriptor is:
      { "kind":"component_anchor",
        "comp_key": f"{c.color}:{c.comp_id}",
        "anchor": c.anchor,
        "dom_size": len(c.mask),
        "apply": callable p->Optional[Coord] that returns c.anchor if p in c.mask else None
      }
    These are NOT subject to S-views ≤128 cap; PT/must-link will union x with apply(x) for all x in Dom.
    """

def component_predicates(components: List[Component]) -> List[Dict]:
    """
    Export PT predicates (input-only) of the form:
      { "kind":"sview_image", "key": f"component:{color}:{comp_id}",
        "mask": c.mask }   # row-major coord list
    PT will use these in its splitter order as membership_in_Sview_image.
    """

def reconstruct_from_components(components: List[Component], H: int, W: int) -> List[List[int]]:
    """
    Helper for algebraic self-check: reassemble a grid by painting each mask with its color.
    """
```

### Deterministic ordering (freeze)

* Colors ascending (0..9).
* For each color, components sorted by anchor row, then anchor col.
* `comp_id` is the index in this sorted order for that color (0-based).
* `mask` sorted row-major (i asc, then j).

---

## Receipts (emit once)

**New section:** `"components"` (additive to your receipts; schema allows extra sections)

Payload:

```json
{
  "count_total": <int>,
  "by_color": { "<c>": <count>, ... },
  "largest": { "color": <c>, "size": <n>, "anchor": [i,j] },
  "anchors_first5": [ { "color": <c>, "id": <k>, "anchor": [i,j], "size": <n> }, ... ],
  "proof_reconstruct_ok": <bool>,
  "examples": { "case": "reconstruct|connectivity|duplicate|order", "detail": {...} }
}
```

* `proof_reconstruct_ok` is `true` iff we can reconstruct G from components exactly (see self-check).
* On any invariant failure, set `proof_reconstruct_ok=false`, populate `examples` with the **first** counterexample, and raise `AssertionError`.

---

## Built-in self-check (debugging = algebra)

Run once via a module-local function `_self_check_components()` behind `ARC_SELF_CHECK=1` (dev mode, same as WO-03/04). Include small synthetic cases:

1. **Reconstruction equals original**

   * Build a small grid with 3 colors and multiple blobs.
   * `build_components` then `reconstruct_from_components` must equal original `G` byte-exact.
   * On mismatch, log `"case":"reconstruct"` with `{p:[i,j], want, got}` and raise.

2. **4-adjacency only (diagonal not connected)**

   * Grid with two same-color pixels touching diagonally.
   * Expect **two** components. If merged, log `"case":"connectivity"` with the two pixels and raise.

3. **Fold-to-anchor must link**

   * For a component with ≥2 pixels, verify that `apply(x)` of its anchor view returns the **same anchor** for every `x` in mask.
   * Additionally verify the proof obligation `G[x] == G[anchor]` for all `x` in mask; if any mismatch, log `"case":"fold_proof"` with first `(x, Gx, Ganchor)` and raise.

4. **Ordering & no duplicates**

   * Ensure components’ `(color, anchor)` order is strictly increasing and that masks have no duplicates; otherwise log `"case":"order|duplicate"`.

The self-check then logs the `"components"` receipt (with `proof_reconstruct_ok=true`) through `receipts.log`.

---

## Acceptance (implementer)

* `build_components`, `component_anchor_views`, `component_predicates`, and `reconstruct_from_components` implemented; no TODOs.
* With `ARC_SELF_CHECK=1`, self-check runs; `"components"` receipt appears with `proof_reconstruct_ok=true`.
* Deterministic across runs: identical receipt payload given the same G.
* Paste the `"components"` JSON fragment in your reply.

---

## Reviewer (after implementation, per your flow)

Write tests that:

* On a crafted grid, component counts by color match expectation; anchors match the top-left pixels.
* Diagonal touch does **not** merge (4-conn only).
* `component_anchor_views` always map to the same anchor for the component; `dom_size` equals mask size.
* `component_predicates` return masks that cover every pixel exactly once across components of the same color (partition property).
* Negative test: swap two anchors in the returned list and assert the receipt self-check complains with `"case":"order"`.

No malformed input tests; controlled ARC inputs.

---

## How this plugs into truth & PT

* **Must-link:** In your truth builder, union-find over **structural S-views** (WO-03/04) **plus** these **component_anchor views**. This merges each component into a single class before PT refinement, which is precisely what region tasks need.
* **PT predicates:** Add `component_predicates()` to the PT splitter pool under `membership_in_Sview_image` (your fixed order: input_color ≺ sview_image ≺ parity). This lets PT split classes cleanly by component when outputs prove different colors per component.

---

## Why debugging stays algebraic

* If a later region-fill or object-wise law misbehaves, the `"components"` receipt tells you **how** the grid was partitioned (counts, anchors, largest), and `proof_reconstruct_ok` certifies that the decomposition is faithful.
* If must-link didn’t merge as expected, you can directly evaluate a component’s **fold view** on the failing pixel from the receipt’s `anchors_first5` and reproduce in one line.
* If PT splitting seems off, the `component_predicates()` masks are explicit; you can verify membership of any `(i,j)` without guessing.

---

This WO gives you component structure as a **provable algebraic layer**: no heuristics, fully deterministic, receipts-visible, and directly usable for both merging (must-link) and splitting (PT). It’s the last structural brick before Paige–Tarjan in WO-06.
