WO-11 turns all proofs into a single, idempotent paint, then un-presents back to raw grids, and validates the **microsuite end-to-end**. Debugging stays algebraic: coverage is a number, and any miss is a single pixel with a complete coordinate path.

---

# WO-11 — Painter + un-present + end-to-end microsuite

## Purpose

1. **Paint once** on the test canvas using the selected per-class laws (from the sieve).
2. **Un-present** outputs to raw coordinates/colors.
3. Prove **idempotence** (paint twice == once), **100% coverage**, **determinism**, and pass the **microsuite**.

## Files

* `src/paint.py` (new)
* touches: `src/receipts.py` (log), uses `morphisms.py`, `present.py`, `shape_law.py`, `laws/keep.py`, `laws/value.py`, `sieve.py`, `truth.py`
* `tests/test_microsuite.py` (added by Reviewer after implementation)

---

## Inputs

* `assignment: Dict[cid -> descriptor]` from WO-10 (must be `status="exact"`).
* The **truth partition** on the presented test input (`Partition` from WO-06).
* **Frames** from Π: `P_test`, `P_in[i]`, `P_out[i]`.
* **Presented** grids: `Xtest` (posed+anchored), `Xin[i]` (posed+anchored), `Yout[i]` (posed-only) for verification in self-checks.
* **Shape law** `(type, (a,b,c,d))` for the task (WO-07).
* Candidate evaluators (KEEP/RECOLOR/BLOCK etc.) already implemented in WO-08/09.

---

## API (exact)

```python
from typing import Dict, List, Tuple, Any, Optional

Coord = Tuple[int,int]

def build_test_canvas_size(P_test, shape_law) -> Tuple[int,int]:
    """
    Compute the output test canvas size (H_out, W_out) from shape law
    applied to the TEST input’s (H_in, W_in).
    """

def painter_once(
    assignment: Dict[int, str],          # cid -> canonical descriptor
    part,                                 # Partition on TEST
    Xtest: List[List[int]],               # presented test input
    Xin: List[List[List[int]]],           # posed+anchored train inputs (needed for KEEP/RECOLOR/BLOCK eval)
    P_test, P_in_list,                    # frames
    shape_law: Tuple[str, Tuple[int,int,int,int]]
) -> List[List[int]]:
    """
    Paints the TEST output once on the OUTPUT canvas (posed-only coordinate system).
    Returns a posed-only OUT grid (no palette inverse yet).
    """

def unpresent_final(
    Y_out_posed: List[List[int]],
    P_out_like_test: Tuple[int, Tuple[int,int], Tuple[int,int]],   # a synthetic OUT frame: (op=(P_out pose for test), anchor=(0,0), shape=(H_out,W_out))
    palette_inverse: Dict[int,int]                                 # inverse map from WO-02
) -> List[List[int]]:
    """
    Un-present the posed OUT grid back to the raw output:
    pose_inv + palette inverse. (Outputs are not anchored.)
    """

def paint_idempotent(
    *same_args_as_painter_once
) -> bool:
    """
    Re-paints by calling painter_once on its own output (as if assignment were re-used).
    Must return True (Y == Y) to assert idempotence.
    """
```

---

## Painting semantics (frozen)

### 0) Canvas size & pullback

* Test output canvas size `(H_out, W_out) = S(H_test, W_test)` via shape law.
* For every pixel `p_out = (i,j)` on this canvas, compute **pullback** (WO-07):

  ```
  p_test = shape_pullback((i,j), (a,b,c,d))       # floor mapping
  if p_test is None: mark as "unseen" (eligible only for CONST-type VALUE laws)
  else: cid = part.cid_of[row_major(p_test)]
  ```

### 1) Evaluate the assigned class law on `p_out`

* If “unseen”:

  * If the descriptor is `CONST(c)` (or other VALUE law that does not read from input), write its `c`.
  * If the descriptor needs `p_test` or `p_in` (KEEP, RECOLOR, BLOCK, reducers), **this is an algebraic bug**, because the law isn’t defined when pullback is None. Raise `AssertionError("law requires pullback but pullback is None")` and record the pixel in receipts `"examples"`.
* If `p_test` defined:

  * **KEEP**: use the class’ chosen view in test frame:

    ```
    q  = V(p_test)
    q' = anchor_fwd(q, P_in[i*].anchor_for_test_paint)    # NO training index; test paint uses TEST input only
    p_in = pose_fwd(q', P_in_test.op)                     # the TEST input's own frame
    color = Xtest[p_in]                                   # KEEP reads from TEST INPUT, not training
    ```

    However, we usually **don’t** need anchor_fwd / pose_fwd for test KEEP: since V maps inside TEST frame, the color is simply `Xtest[q]` (presented). Keep the general form only if your KEEP descriptors were written to require input frame. Simpler and recommended:

    > **Recommended**: KEEP at test time is `color = Xtest[ V(p_test) ]`, provided V returns a TEST-frame coordinate.
  * **VALUE**:

    * `CONST(c)`: write `c`
    * `RECOLOR(π)`: compute `cin = Xtest[p_test]`; write `π[cin]`
    * `BLOCK(k)`: with class anchor `anchor(cid)`, compute `rel=(p_test - anchor)`, `base=(rel//k)`, `q=anchor+base`; write `Xtest[q]`
    * Reducers generally require only class-wise constants learned during admissibility; write that `c`.

> **Important**: **Test paint never reads training outputs.** It reads the **test input** (after Π) and constants learned during proofs.

### 2) Idempotence

`painter_once` must be **idempotent**: painting again produces identical pixels. This holds because test-time evaluations are **pure input-carrying or constants**; they do not depend on the output you are producing.

---

## Receipts (emit once)

Section: `"paint"`

Payload:

```json
{
  "pixels_total": <int>,
  "pixels_painted": <int>,
  "coverage_pct": <float>,        // must be exactly 100.0
  "by_law": { "KEEP:tile_alt_row_flip": 36, "CONST(c=2)": 12, ... },
  "idempotent_ok": true,
  "examples": { }                 // only populated on failure
}
```

* If any pixel is “unseen” and the chosen law cannot produce a color there, set `idempotent_ok=false`, `coverage_pct<100`, and populate `examples` with the **first** `(i,j,cid,descriptor)` that failed plus a minimal path: `{p_test: ..., why: "pullback None" | "view undefined"}`. Then raise `AssertionError("paint failed: <reason>")`.

Log with `receipts.log("paint", payload)`.

---

## Built-in self-check (debugging = algebra)

Guarded by `ARC_SELF_CHECK=1`, `_self_check_paint()` must run after a tiny synthetic assignment:

1. **KEEP on test**

   * Build a grid where the assigned law is `KEEP:translate(di=1,dj=0)` for a class covering the whole canvas.
   * Assert every output pixel equals `Xtest[(i-1,j)]` (mod rules) and coverage is 100%.

2. **RECOLOR**

   * Assign `RECOLOR(π={2:6,3:1})` to a class; check pixels where `Xtest` has 2 or 3 map to 6 or 1, all others unchanged if class assignment says CONST for those.

3. **BLOCK(k)**

   * Assign `BLOCK(k=2)` with a known anchor; verify blow-up behavior on a toy grid.

4. **Idempotence**

   * Call `painter_once` twice; assert byte-equal outputs.

Any failure includes the **first** pixel witness `{p_out, p_test, cid, descriptor, expected, got}` and raises `AssertionError("painter self-check failed: <case>")`.

---

## Acceptance (implementer)

* `painter_once` fills **every** pixel (coverage 100.0); `idempotent_ok = true`.
* `unpresent_final` returns raw output by **pose_inv + palette inverse**, no anchoring.
* With `ARC_SELF_CHECK=1`, self-check passes.
* Implementer pastes the `"paint"` receipt sample showing coverage and by-law counts from one real task.

---

## Reviewer (after implementation)

* Write tests that:

  * Confirm coverage is exactly 100% and that “unseen + KEEP/RECOLOR/BLOCK” raises with the recorded pixel.
  * Confirm un-present is exact inverse of pose for outputs and uses **inverse palette** from WO-02 (no output anchoring).
  * Confirm idempotence on a composed assignment (KEEP + VALUE classes).
  * Confirm determinism: two runs same JSON, same hash.

No malformed inputs; ARC is controlled.

---

## Prohibited

* Reading training outputs during test paint.
* Anchoring outputs.
* Allowing coverage < 100% to pass.

---

## How Claude should use receipts to debug (explicit)

* If coverage < 100% or idempotence fails, read `"examples"`:

  * If `"pullback None"`: your assigned law for that class needs a CONST-style alternative or the shape law is wrong; reproduce `p_test = pullback(p_out)` to see it.
  * If `"view undefined"`: your KEEP view returns None on some test pixel; fix V’s bounds or reject KEEP earlier (WO-08).
  * If `"expected/got"` mismatch: recompute `color = eval(descriptor, p_test, Xtest, anchor(cid))` for that **one** pixel.

This keeps debugging algebraic: a single witness coordinate explains the miss.

---

## End-to-end microsuite (Reviewer adds after)

* `tests/test_microsuite.py` loads your six microsuite tasks, runs Π → truth → shape → KEEP/VALUE admissibility → sieve → paint → un-present, and asserts:

  * predictions equal golden outputs for those tasks,
  * receipts `"present"`, `"sviews"`, `"truth"`, `"shape"`, `"laws"`, `"selection"`, `"paint"` exist,
  * determinism hash stable across two runs.

---

With WO-11 you’ve closed the loop: proofs → one paint → raw output, receipts-tight and idempotent. From here WO-12 can run the full training set, report `missing_descriptor` certificates if any, and prepare the Kaggle driver.
