WO-07 keeps the same “debugging = algebra” discipline and makes size change purely mechanical.

---

# WO-07 — Shape law + pullback (affine fit with floor mapping, bbox fallback)

## Purpose

Learn the **affine size law** (S(H,W)=(aH+b,;cW+d)) from training sizes with strict precedence, then expose a **total pullback** on the test canvas using **floor mapping**. This is the only way downstream KEEP reads are allowed to cross canvases. All checks produce receipts and counterexamples so failure reduces to arithmetic, not vibes.

## Files

* `src/shape_law.py` (new)
* Uses: `src/receipts.py`

## Hard rules

* No TODOs, no stubs, no new deps.
* Input is **posed** sizes only (from Π): you receive ((H_{\text{in}},W_{\text{in}},H_{\text{out}},W_{\text{out}})) per training pair, already *posed* (no output anchors).
* Deterministic precedence:

  1. **multiplicative**: (b=d=0), integers (a,c\ge1)
  2. **additive**: (a=c=1), integers (b,d\ge0)
  3. **mixed**: integers (a,c\ge1) and (b,d\ge0) (at least one of (b,d) non-zero or one of (a,c) ≠ 1)
  4. **bbox** fallback (content-law) only if all affine fail
* **Pullback is floor**: (i_{\text{in}}=\big\lfloor\frac{i_{\text{out}}-b}{a}\big\rfloor,; j_{\text{in}}=\big\lfloor\frac{j_{\text{out}}-d}{c}\big\rfloor).
  Return **None** only if ((i_{\text{in}},j_{\text{in}})) is out of input bounds.
  Never require the equality (a\cdot i_{\text{in}}+b=i_{\text{out}}) (over-constrains).
* Receipts use the **existing** `"shape"` section (type, law, verified_on). No schema changes.

---

## API (implement exactly)

```python
from typing import List, Tuple, Literal, Optional

SizeQuad = Tuple[int,int,int,int]  # (Hin, Win, Hout, Wout)
Law      = Tuple[int,int,int,int]  # (a, b, c, d)
LawType  = Literal["multiplicative","additive","mixed","bbox"]

def learn_law(sizes: List[SizeQuad]) -> Tuple[LawType, Law]:
    """
    Fit the smallest-precedence law that matches ALL training size pairs.
    Precedence: multiplicative ≺ additive ≺ mixed ≺ bbox.
    Raises AssertionError with a minimal counterexample if no law can be learned.
    """

def pullback(i_out: int, j_out: int, law: Law, Hin: int, Win: int) -> Optional[Tuple[int,int]]:
    """
    Floor pullback. Return None iff the mapped (i_in,j_in) is out of bounds [0..Hin-1]x[0..Win-1].
    """

def log_shape_receipt(law_type: LawType, law: Law, verified_on: int) -> None:
    """
    receipts.log("shape", {"type": law_type, "law": [a,b,c,d], "verified_on": verified_on})
    """
```

---

## Fitting algorithm (deterministic, frozen)

Let the input list be (Q={(H_k,W_k,h_k,w_k)}_{k=1..m}).

### 1) Multiplicative

* For each k, compute (a_k=\frac{h_k}{H_k},;c_k=\frac{w_k}{W_k}).
* **Admissible iff** every (a_k,c_k) are positive integers and (a_k) is constant across k and (c_k) is constant across k.
  If yes, return (a=\text{const}(a_k),;b=0,;c=\text{const}(c_k),;d=0).

### 2) Additive

* Check (a=c=1). For each k, set (b_k=h_k-H_k,;d_k=w_k-W_k).
* **Admissible iff** all (b_k) are identical (\ge0) and all (d_k) identical (\ge0).
  If yes, return (a=1,b=\text{const}(b_k),c=1,d=\text{const}(d_k)).

### 3) Mixed

* Compute candidate integers (a) and (c) from consistent ratios when they exist:

  * If (\forall k:; H_k\mid h_k) and (h_k/H_k) constant, set that constant to (a). Otherwise set (a=1).
  * If (\forall k:; W_k\mid w_k) and (w_k/W_k) constant, set that constant to (c). Otherwise set (c=1).
* Solve (b_k=h_k-aH_k,;d_k=w_k-cW_k). **Require** all (b_k\equiv b\ge0) equal and all (d_k\equiv d\ge0) equal.
* **Reject** if (a=c=1) (that’s additive) or if (b=d=0) (that’s multiplicative).
* If multiple ((a,c)) seem admissible (rare), choose the **lexicographically minimal** ((a,c,b,d)) by the tuple ((a,c,b,d)) to freeze determinism.

### 4) BBox fallback (content-law)

* On the **posed** input grids (palette/pose/anchor already applied to inputs), compute each input’s **foreground bounding box** of non-zero pixels: heights (H^{bbox}_k), widths (W^{bbox}_k).
* **Admissible iff** for all k: (h_k=H^{bbox}_k) and (w_k=W^{bbox}_k).
  Return a *conventional encoding* as a law: set (a=1,b=0,c=1,d=0) and treat type `"bbox"` specially (the pullback becomes the identity into the anchored input’s bbox; see note below).

**Failure mode:** If none fits, raise `AssertionError("shape fit failed")` and include the first (k) that violates all three affine families in the exception message. The receipt will still log type+law once you actually learn one; until then, the exception is your algebraic debug.

**Note on bbox pullback:** since inputs were **anchored** in Π, the top-left of the bbox is ((0,0)), so *for bbox type* you may implement `pullback` as identity on the bbox domain (and None outside the bbox).

---

## Receipts (emit once)

Use the **existing** schema:

```python
log_shape_receipt(law_type, law, verified_on=len(sizes))
```

No extra keys. Debug info goes to exceptions during the self-check below (with the first counterexample indices included in the message).

---

## Built-in self-check (debugging = algebra)

Behind `ARC_SELF_CHECK=1`, run `_self_check_shape()` once when `learn_law` is called the first time:

1. **Multiplicative**
   `Q={(2,3,6,9),(4,5,12,15)}` → expect `(type="multiplicative", law=[3,0,3,0])`.
   If not, raise `AssertionError("multiplicative failed: k=<idx>, got=..., want=...")`.

2. **Additive**
   `Q={(5,7,7,10),(3,4,5,7)}` → expect `(type="additive", law=[1,2,1,3])`.

3. **Mixed**
   `Q={(3,4,9,6),(5,4,15,6)}` → heights ×3, widths +2 → expect `(type="mixed", law=[3,0,1,2])`.

4. **BBox fallback**
   Provide posed inputs whose non-zero bbox sizes equal outputs though affine fails (e.g., height add differs across trains). Expect `type="bbox"`.

5. **Pullback floor semantics**
   For each learned affine law above, pick a few ((i_{\text{out}},j_{\text{out}})) that land between multiples; assert pullback returns a valid input coord by floor and never requires exact equality. Also pick a true OOB and assert `None`.

If any fails, raise with a message that names the *first* offending size quad or pixel so Claude fixes arithmetic directly.

---

## Acceptance (implementer)

* `learn_law` returns a lawful `(type, law)` by precedence on any valid input set; raises an assertion with a concrete counterexample on impossible sets (algebraic bug).
* `pullback` matches the frozen floor definition and OOB policy.
* With `ARC_SELF_CHECK=1`, the self-check passes.
* Implementer pastes the `"shape"` receipt JSON fragment (`type`, `law`, `verified_on`).

---

## Reviewer (after implementation)

Write tests that:

* Confirm precedence: when both multiplicative and additive would “appear” to fit individually across subsets, the full set forces the higher-priority true one; construct cases that would trick a greedy fit.
* Confirm mixed chooses lexicographically minimal ((a,c,b,d)) among alternatives.
* Confirm bbox fallback triggers only when *all* affine families fail, and that bbox sizes are computed on **posed inputs** (anchored), not raw.
* Confirm pullback uses floor: for e.g. `(a,b,c,d)=(3,1,2,0)`, check a grid of output pixels and that OOB logic is the *only* reason for `None`.

No malformed input tests; ARC inputs are controlled.

---

## Prohibited

* Any non-floor pullback or “exact multiple” requirement.
* Negative (a) or (c); negative (b) or (d).
* Using outputs to *fit* bbox; bbox is derived from posed inputs.

---

## Why debugging stays algebraic

* Every misfit produces a named smallest counterexample: a specific size quad (k) that breaks the family.
* Every pullback bug reduces to a single pixel and a closed-form arithmetic check.
* The receipt is a 3-field certificate: `type`, `law`, `verified_on`. If a later KEEP or CONST seems to “miss,” you can recompute the expected source with the same formula and see if the issue is shape or law.
