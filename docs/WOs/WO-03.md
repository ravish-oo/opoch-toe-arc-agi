# WO-03 — S-views v1 (identity, D4-preserving, overlap translations, closure depth=2)

## Purpose

Construct the first proof basis of structural views (S-views) from the *presented test input* only. Each admitted view M is a partial self-map whose domain satisfies **G(M(x)) = G(x)**. Provide a deterministic **closure of depth 2** and cap the total at **≤128** views. Emit receipts and a built-in self-check so debugging is pure algebra: a failed proof yields a concrete counterexample pixel.

## Files

* `src/sviews.py` (new)
* Uses: `src/morphisms.py` (for D4 ops), `src/receipts.py`

## Hard rules

* No TODOs. No extra deps. Pure functions. One receipt at end.
* Input is strictly the **presented test input grid** (after Π from WO-02).
* Deterministic enumeration and ordering.
* Every admitted view includes: name, parameters, domain size, and first counterexample if rejected (not kept in result, but logged during self-check if any bug).

## Definitions from anchors (frozen)

* S-view M is a partial function M: Ω ⇀ Ω with **proof**: ∀x∈Dom(M), G(M(x))=G(x).
* Admitted families in v1:

  1. **identity**
  2. **D4-preserving** ops: those d4 ∈ {0..7} that leave G invariant (pose acts on coordinates of the *posed* grid)
  3. **overlap translations** Δ=(di,dj): where the overlap domain Ω∩(Ω+Δ)≠∅ and equality holds on the overlap
* **Closure depth 2**: from a base set V, admit compositions up to length 2: {M, N, M∘N} where defined. Do **not** exceed depth 2. Deduplicate by *image signature* (see below). Cap total admitted views to ≤128, deterministic truncation if overflow.

## API (implement exactly)

```python
from typing import List, Tuple, Dict, Callable, Optional, Any

Coord = Tuple[int,int]
Shape = Tuple[int,int]

class SView:
    # immutable record
    def __init__(self, kind: str, params: Dict[str, Any],
                 dom_size: int, apply_fn: Callable[[Coord], Optional[Coord]]):
        self.kind = kind          # "identity" | "d4" | "translate" | "compose"
        self.params = params      # e.g., {"op":3} or {"di":1,"dj":-2} or {"left":<sig>,"right":<sig>}
        self.dom_size = dom_size  # |Dom(M)|
        self.apply = apply_fn     # M(x): returns None if x∉Dom(M)

def build_base_views(G: List[List[int]]) -> List[SView]:
    """
    Build identity, D4-preserving views, and overlap translations with proofs.
    Identity is always admitted. D4 view admitted iff invariant.
    For translations, enumerate Δ in bounded window (see Bounds), admit iff equality on overlap.
    """

def build_closure_depth2(G: List[List[int]], base: List[SView]) -> List[SView]:
    """
    Deterministically build {M}∪{N}∪{M∘N} with depth≤2, dedup by image signature.
    Truncate to ≤128 by deterministic order.
    """

def build_sviews(G: List[List[int]]) -> List[SView]:
    """
    Convenience: base -> closure -> cap; returns final list of admitted views.
    """
```

### Deterministic Bounds and Order

* **Translations Δ**: enumerate di in [−H+1..H−1], dj in [−W+1..W−1], but **skip (0,0)** (identity handled separately). Iterate in lex order on (|di|+|dj|, di, dj) so small moves come first and tie-break is stable.
* **D4 check**: a D4 op with id `op` is admitted iff ∀(i,j) in Ω, `G[i,j] == G[pose_fwd((i,j), op, (H,W))]`. Domain is Ω (total view).
* **Translate check**: domain Ω∩(Ω+Δ) (i.e., i,i+di ∈ [0..H−1], j,j+dj ∈ [0..W−1]). Admit iff equality on this overlap; `dom_size` is number of valid positions.
* **Composition (depth 2)**: for any M,N in base, define M∘N with domain {x | x∈Dom(N) and N(x)∈Dom(M)}. **Do not** go beyond length 2. Set `kind="compose"` and `params={"left":sig(M), "right":sig(N)}`.
* **Dedup by image signature**: For a view V, compute `sig(V)` as a 64-bit hash (or tuple) of the multiset of pairs {(x, V(x))} in row-major x order over Dom(V). Two views with identical sig are considered equal; keep the first by deterministic order: identity first, then D4 (op ascending), then translations in the specified order, then compositions in lex order of (sig(left), sig(right)).
  Note: Store only the **final admitted** unique views; do not keep duplicates.

### Proof obligations (admission)

* Each candidate must be **proven** by directly checking `G[x] == G[V(x)]` for all x in Dom(V). If any mismatch, **reject** the candidate (do not include it).
* `dom_size == 0` candidates are **rejected** (no vacuous proofs).
* If `G` is constant, only identity and D4 are expected to admit with full domain; translations admit with full overlap automatically, that’s fine.

## Receipts (emit once)

Section: `"sviews"`
Payload:

* `"count": int`  (final admitted count after closure & dedup)
* `"depth_max": int` (should be 2 or 1 depending on whether any composition admitted)
* `"views": List[{ "kind": str, "dom_size": int, "meta": {...} }]`

  * For D4: `meta={"op": op}`
  * For translation: `meta={"di":di,"dj":dj}`
  * For compose: `meta={"left": "<sig>", "right": "<sig>"}` (stringified canonical sigs)
* `"proof_samples": List[{ "kind": str, "ok": bool, "checked": int }]`
  (e.g., sample counts for D4 and a couple of translations to show proof happened)
* `"closure_capped": bool` (true if the 128 cap truncated anything)
* `"examples"` (only on failure): minimal counterexample `{kind, params, x, gx, gvx}`

Use `receipts.log("sviews", payload)` after the self-check.

## Built-in self-check (debugging = algebra)

Implement `_self_check_sviews(G_synths: List[List[List[int]]])` and call it once from `build_sviews` when an env var `ARC_SELF_CHECK=1` is set (so you can run fast in normal mode, and enable checks during dev). The self-check must:

1. **D4 invariance sanity**
   Construct a small grid `G1` with a known D4 symmetry (e.g., 180-symmetry). Run `build_base_views(G1)` and assert that the corresponding D4 op is admitted with `dom_size == H*W`. If not, log `"examples"` with the first `(i,j)` where `G1[i,j] != G1[pose_fwd(...)]` and raise `AssertionError("d4 preserve failed")`.

2. **Translation equality on overlaps**
   Construct `G2` with a known horizontal periodicity (e.g., period 2 stripe). Assert that translations with dj=±2 are admitted with positive `dom_size`, and dj=±1 are *not* admitted (unless G2 is constant). On mismatch, log a minimal counterexample and raise `AssertionError("translation proof failed")`.

3. **Closure depth = 2 and dedup**
   Pick a `G3` where composing two admitted translations equals a third translation; assert that composition does **not** introduce a duplicate (same sig), and final `count` respects dedup. If not, raise with `"compose dedup failed"`.

4. **Cap respected**
   For a crafted `G4` (busy pattern), ensure that if >128 candidates are possible, the final set is exactly 128 with deterministic truncation, and `"closure_capped": true`.

If any check fails, include the first counterexample in `"examples"` and raise. Otherwise, log the `"sviews"` receipt.

## Acceptance (implementer)

* `build_sviews` returns a deterministic list of admitted views on the presented test input.
* With `ARC_SELF_CHECK=1`, the self-check runs and logs receipts; no failures.
* Receipts show `count ≤ 128`, correct `depth_max`, and reasonable proof samples.

## Reviewer (after implementation)

* Write tests that:

  * Confirm on small crafted grids that only preserving D4 ops admit; non-preserving ones reject.
  * Confirm an expected translation admits, adjacent translations reject when the pattern requires a larger period.
  * Confirm closure adds M∘N but dedups when equal to an existing view.
  * Confirm the 128 cap triggers on a busy grid with stable order.
* No malformed JSON tests; controlled inputs only.

## Prohibited

* Using outputs or training data here. **Test input only**.
* Admitting a view without full proof over its domain.
* Depth > 2 or cap > 128.
* Nondeterministic enumeration or hashing (seed any hash or use tuple signatures instead).

## How receipts guide debugging

* If a later Paige–Tarjan step behaves oddly, inspect `"sviews"` to confirm which invariances were actually admitted and their domain sizes.
* If a specific view causes bad must-links, the receipt’s `views` list lets you reproduce the exact mapping (via kind+params) and verify equality pixel-by-pixel.
* If closure exploded or order drifted, `"closure_capped"` plus the deterministic enumeration makes the discrepancy obvious.

---

This WO keeps everything algebraic: candidates are admitted strictly by proof, closure is a small monoid up to depth 2, and receipts expose exactly which equalities you trusted.
