# WO-01 — Morphisms Kernel (the only coordinate algebra)

## Purpose

Implement the complete, deterministic coordinate calculus used everywhere else. All later modules depend on these identities being exact. This is the first place we emit receipts and do algebraic debug.

## Files

* `src/morphisms.py`
* `src/receipts.py` (already exists from WO-00; you will call it)

## Hard requirements

* No new dependencies.
* No TODOs, stubs, or partials.
* Deterministic behavior only.
* All functions pure (no I/O except calling `receipts.log` once at the end).

## Data types

Use these exact types.

```python
from typing import Tuple, Literal, Optional, Dict, Any

Coord = Tuple[int, int]                  # (i, j)
Shape = Tuple[int, int]                  # (H, W)

D4 = Literal[0,1,2,3,4,5,6,7]            # see table below
Anchor = Tuple[int, int]                 # (dy, dx)

Frame = Tuple[D4, Anchor, Shape]         # (d4_op, (dy,dx), (H,W))
Law   = Tuple[int, int, int, int]        # (a,b,c,d)
```

## D4 enumeration (freeze this)

* 0: identity
* 1: rot90
* 2: rot180
* 3: rot270
* 4: flip_h (mirror over vertical axis)
* 5: flip_h + rot90
* 6: flip_h + rot180
* 7: flip_h + rot270

Implement these exactly. For each op you must define both `pose_fwd` and `pose_inv` relative to a **posed shape** `(H,W)` of the grid **before** applying that op.

## API to implement

```python
def pose_fwd(p: Coord, op: D4, shape: Shape) -> Coord: ...
def pose_inv(p: Coord, op: D4, shape: Shape) -> Coord: ...

def anchor_fwd(p: Coord, a: Anchor) -> Coord: ...
def anchor_inv(p: Coord, a: Anchor) -> Coord: ...

def shape_pullback(p_out: Coord, law: Law) -> Optional[Coord]:
    """Floor pullback. Return None iff out-of-bounds after floor."""

def test_to_out(
    p_test: Coord,
    P_test: Frame,              # (op_t, (dy_t,dx_t), (Ht,Wt))
    P_out:  Frame               # (op_o, (0,0),      (Ho,Wo))  pose-only frame
) -> Coord:
    """
    The TEST→OUT composite used for conjugating reads of training outputs.
    """

def out_to_in_keep(
    p_out: Coord,
    P_out:  Frame,              # training output frame (pose-only)
    P_in:   Frame,              # training input frame (pose+anchor)
    view:   Dict[str, Any],     # neutral KEEP view descriptor, must include a callable V_test: Coord->Coord over test frame
    V_test_fn                   # callable taking Coord->Coord on the test frame (injected by caller)
) -> Optional[Coord]:
    """
    The OUT→IN composite for KEEP laws. Return None iff the composed mapping is undefined.
    """
```

### Semantics you must follow

* `pose_inv(pose_fwd(x,op,shape), op, shape) == x` for all in-bounds `x`.

* `anchor_inv(anchor_fwd(x,a), a) == x` for all integer `x`.

* `shape_pullback`: floor division only; OOB check is the only reason to return `None`. Never require exact equality a*i_in + b == i_out.

* `test_to_out`: exact order is:

  ```
  # p_test lives in TEST input’s posed-and-anchored frame
  q = pose_inv(p_test, op_t, (Ht,Wt))
  q = anchor_inv(q, (dy_t,dx_t))
  q = pose_fwd(q, op_o, (Ho,Wo))
  return q
  ```

* `out_to_in_keep`: exact order is:

  ```
  # p_out lives in TRAIN output’s posed-only frame
  q = pose_inv(p_out, op_o, (Ho,Wo))
  q = V_test_fn(q)                    # view runs in TEST frame coordinates
  q = anchor_fwd(q, (dy_i,dx_i))
  q = pose_fwd(q, op_i, (Hi,Wi))
  return q or None if any substep undefined
  ```

Note: At WO-01 we don’t yet have real views; the caller injects a small lambda `V_test_fn` for testing. Later, laws will provide this from descriptors.

## Receipts (emit once, end of module)

Section: `"morphisms"`
Payload keys:

* `"d4_table_ok": bool` — verified inverses for all ops on random shapes and corners.
* `"anchor_id_ok": bool` — verified identities on random coords.
* `"pullback_floor_ok": bool` — verified that pullback never rejects an in-bounds identity law `(1,0,1,0)`.
* `"composites_checked": int` — number of random composite checks run.
* `"examples"`: minimal counterexample if any identity fails, as `{case:"pose|anchor|pullback|composite", op?, shape?, a?, p?, got?, want?}`.

Call `receipts.log("morphisms", payload)` at the end of a built-in self-check (see Debug playbook below). Do not log per-call.

## Built-in self-check (debugging is algebra)

Implement a private `def _self_check():` and call it once from module import or an explicit `init()` function (your choice). It must:

* Randomly sample 64 shapes `(H,W)` in [1..30], 8 D4 ops, 128 points per shape for pose identities.
* Randomly sample 128 anchors in [−15..15]² for anchor identities.
* Check floor-pullback with `(a,b,c,d)=(1,0,1,0)` over a random 20×20 output lattice maps to the same input lattice and never returns None.
* For composites, fabricate a TEST frame and OUT/IN frames with random ops and anchors, and a `V_test_fn = identity`. Verify that `out_to_in_keep(test_to_out(p, P_test, P_out), P_out, P_in, view, identity) == pose_fwd(anchor_fwd(p, a_i), op_i, (Hi,Wi))` for random `p` (i.e., the diagrams commute when view=identity).

If any check fails:

* Include the **first** counterexample in the morphisms receipt under `"examples"`.
* Raise an `AssertionError` with a one-line string: `"morphisms identity failed: <case> <summary>"`.

This makes debugging algebraic: the receipt tells which identity failed and shows a concrete `(H,W), op, p` to reproduce.

## Acceptance (what Claude must ensure before handing off)

* Code compiles; no TODOs or unused skeletons.
* `_self_check()` runs once and logs the `"morphisms"` receipt.
* No failures or flakiness under repeated runs.
* Deterministic: running twice produces identical receipts payload (ignoring timestamps, which we do not include).
* Implementer pastes the receipt JSON fragment in the WO reply so you can read it immediately.

## Prohibited

* Any tolerance, rounding other than floor in pullback, or approximate comparisons.
* Any randomness that influences outputs or receipts; randomness only inside `_self_check` and seeded (`random.seed(1337)`).
* Caching with hidden global state.

## How you’ll “see” receipts to debug

* Run the module once; it logs `"morphisms"` to the global receipts aggregator (from WO-00). The aggregator writes a canonical JSON for the current task context (or a dummy task id during dev).
* When something breaks later (e.g., in presenting or PT), you already know the coordinate layer is correct. If not, the morphisms receipt includes the exact counterexample for Claude to fix algebraically.

---
