**WO-08 — KEEP law (admissibility engine)** that keeps “debugging = algebra” front and center, and tells Claude exactly how to use receipts to fix things instead of skipping tests. Reviewer can lift acceptance and counterexample patterns directly.

---

# WO-08 — KEEP law (admissibility engine)

## Purpose

Admit **KEEP** laws per truth-class by **proof**, not search. For each candidate view (V) defined in the **test frame**, prove via **equivariant conjugation** that copying from input through (V) reproduces **every** training output on **all** pixels of that class. If any pixel disagrees, reject (V). If (V) is undefined for any pixel, reject (V) (no partial KEEP). Emit receipts with the **first counterexample** so debugging reduces to a single coordinate identity, not guesswork.

## Files

* `src/laws/keep.py`  (new)
* uses: `src/morphisms.py` (WO-01), `src/receipts.py` (WO-00), `src/shape_law.py` (WO-07)

## Inputs

* Truth partition (Q): `Partition` from WO-06 on the **presented test input**.
* Frames: `P_test`, `P_in[i]`, `P_out[i]` from WO-02.
* Presented grids: `Xin[i]` (train inputs, posed+anchored), `Yout[i]` (train outputs, posed only), `Xtest` (test input, posed+anchored).
* Shape law `(type, law)` from WO-07 for each task (single law per task).
* Candidate view catalogue (deterministic order; see below).

## Candidate view catalogue (frozen, deterministic order)

Views are defined **in the test frame**. Each descriptor is neutral, no grid captured.

Order (from simplest to richest), names as strings:

1. `identity`
2. `d4:op=<0..7>`  (only those ops admitted in sviews if you choose to restrict; or full 0..7)
3. `translate:di=<int>,dj=<int>`  (bounded by |di|+|dj| ≤ max(H,W); lex order by (|di|+|dj|, di, dj))
4. `residue_row:p=<k>` (if sviews admitted gcd k>1)
5. `residue_col:p=<k>`
6. `tile` | `tile_alt_row_flip` | `tile_alt_col_flip` | `tile_checkerboard_flip`
7. `block_inverse:k=<k>`
8. `offset:b=<int>,d=<int>`

> Determinism: enumerate in exactly this order; within each family, lexicographic over parameters.

## API (exact)

```python
from typing import List, Dict, Tuple, Optional, Callable, Any
Coord = Tuple[int,int]

class KeepCandidate:
    def __init__(self, name: str, params: Dict[str, Any],
                 make_V_test: Callable[[Coord], Optional[Coord]]):
        self.name = name        # e.g., "translate"
        self.params = params    # e.g., {"di":1,"dj":-2}
        self.V = make_V_test    # callable on TEST frame coords

def enumerate_keep_candidates(H: int, W: int,
                              sviews_meta: Dict[str, Any]) -> List[KeepCandidate]:
    """
    Deterministically build the candidate list for the test canvas size HxW,
    using any residue info from sviews_meta (e.g., {"row_gcd":3,"col_gcd":2}).
    """

def admit_keep_for_class(
    cid: int,
    class_pixels_test: List[Coord],      # coords in TEST frame (within truth class)
    Xin: List[List[List[int]]],          # posed+anchored train inputs
    Yout: List[List[List[int]]],         # posed-only train outputs
    P_test, P_in_list, P_out_list,       # frames
    shape_law: Tuple[str, Tuple[int,int,int,int]],
    candidates: List[KeepCandidate],
) -> List[Dict[str, Any]]:
    """
    Return the subset of candidates that are ADMITTED for this class,
    each as {"cid": cid, "descriptor": "<name(params)>", "proof": {...}}.
    Reject a candidate if:
      - V is undefined on ANY training pixel of the class; or
      - the color copied through conjugation differs from Yout, even once.
    """
```

### The admissibility proof (frozen)

For each training pair `i` and each **output** pixel (p_{\text{out}}) that belongs to the class (cid) (i.e., its TEST pullback sits in the class):

1. Pull back the output pixel into TEST frame:
   ( q = \text{pose_inv}(p_{\text{out}}, P_{\text{out}}^i) )

2. Apply the candidate view in TEST frame:
   ( q' = V(q) )
   If undefined → **reject** (V) for this class (no partials).

3. Move to the i-th input frame:
   ( q'' = \text{anchor_fwd}(q', P_{\text{in}}^i.\text{anchor}) )
   ( p_{\text{in}} = \text{pose_fwd}(q'', P_{\text{in}}^i.\text{d4}) )

4. Compare colors:
   Check ( X_{\text{in}}^i[p_{\text{in}}] == Y_{\text{out}}^i[p_{\text{out}}] ).
   If mismatch → **reject** (V) and **record first counterexample**.

> Shape law is **not** used here; we’re proving KEEP against **train** pairs, which already have consistent sizes (posed grids). Shape law is used later for test paint, not for training proofs.

> Coverage rule: a KEEP candidate must be **defined** for **every** output pixel in this class for **every** training pair that observes that pixel (OOB in Yout is “not observed” and skipped). Any undefined mapping on an observed pixel → reject.

## Receipts (new subsection inside `"laws"`)

For each **admitted** candidate, emit:

```json
{
  "class_id": <cid>,
  "descriptor": "translate(di=1,dj=-2)" ,   // canonical
  "proof": {
    "trains_checked": <m>,
    "pixels_checked": <N>,
    "undefined_hits": 0,
    "mismatch_hits": 0
  }
}
```

For each **rejected** candidate, do **not** list it in `"admitted"`, but when `ARC_SELF_CHECK=1` you **must** also emit a `"keep_debug"` receipt with the **first counterexample** only:

```json
{
  "cid": <cid>,
  "descriptor": "tile_alt_row_flip",
  "witness": {
    "train_idx": <i>,
    "p_out": [r,c],
    "p_test": [rt,ct],    // after pose_inv from OUT
    "p_test_after_V": [rv,cv] | null,   // null if undefined
    "p_in": [ri,ci],
    "xin": <color_in>,
    "yout": <color_out>
  }
}
```

This is the algebraic breadcrumb Claude uses to fix things—one pixel, five coordinates.

Call once per class: `receipts.log("laws", {"admitted":[...], "keep_debug":[...]})`
(The schema allows extra fields; Reviewer will verify shapes.)

## Built-in self-check (debugging = algebra)

Guarded by `ARC_SELF_CHECK=1`, run `_self_check_keep()` at the end of `admit_keep_for_class` for a small synthetic fixture:

1. **Positive proof**
   Build a tiny pair where `tile_alt_row_flip` is the only KEEP that works. Verify it is admitted; `identity` rejected with a single witness; `pixels_checked` matches class size × train count (minus OOB).

2. **Undefined mapping rejection**
   Construct a case where a translation goes OOB for some class pixel in one train. Expect **undefined_hits > 0** and the candidate rejected; witness must show `"p_test_after_V": null`.

3. **Equivariance sanity**
   Flip `P_in` D4 in one train and verify the same KEEP candidate remains admitted because of conjugation; if not, the witness shows algebraic slippage.

Fail fast with `AssertionError("keep self-check failed: <case>")` and the first witness in the message.

## Acceptance (implementer)

* Deterministic candidate enumeration; no TODOs.
* For each class, admitted list contains only candidates with **zero** undefined/mismatch and non-zero `pixels_checked`.
* With `ARC_SELF_CHECK=1`, self-check passes and `keep_debug` records only the **first** counterexample per rejected descriptor.
* Implementer pastes the `"laws"` receipt (admitted + keep_debug) for one real class (any task), proving the structure.

## Reviewer (after implementation)

* Write tests **after** code lands that:

  * Construct a class where only one view is correct; others produce a witness.
  * Assert **partial KEEP gets rejected** (undefined witness).
  * Assert **equivariance**: changing frames (D4/anchor) across trains does not affect admission.
  * Assert determinism: candidate order stable; `admitted` list equal across runs; first witness stable for a known bad view.
  * Assert `pixels_checked` equals the count of observed pixels (OOB skipped) across trains × class size.

If Claude claims “won’t run one test,” you reject, and ask them to read the **keep_debug witness** and fix the one algebraic step; there is no skipping with this WO.

## Prohibited

* Sampling proofs (must check **all** observed pixels).
* Admitting partial KEEP (any undefined on observed pixel rejects).
* Using shape law or outputs to *define* (V); (V) is independent and evaluated in the **test frame**.
* Capturing grids inside descriptors (must remain neutral).

## How Claude should debug (explicit)

1. Run with `ARC_SELF_CHECK=1` to get `keep_debug` witnesses.
2. Pick the **first** failing descriptor’s witness; reproduce the five-step mapping by hand:

   * `p_out` → `pose_inv` → `p_test` → `V(p_test)` → `anchor_fwd` → `pose_fwd` → `p_in`.
   * Compare `Xin[i][p_in]` vs `Yout[i][p_out]`.
3. If undefined: adjust (V) bounds logic or reject candidate.
4. If mismatch: either the descriptor math is wrong (e.g., sign or mod), or the descriptor simply doesn’t apply—reject it and rely on the one that admits.
5. Do **not** skip tests. One witness is enough to fix it.

---

This WO turns KEEP into a proof object. The receipts give a one-pixel counterexample that pins any bug to a specific algebraic step, which is exactly how you’ve been catching issues.

## Additional Clarity
You’re right to press here. Two crisp points:

1. **WO-08 already included those families.**
   In my WO-08 spec, the KEEP catalogue explicitly listed:

   * `tile`, `tile_alt_row_flip`, `tile_alt_col_flip`, `tile_checkerboard_flip`
   * `block_inverse(k)`
   * `offset(b,d)`
     The implementer skipped them, claiming they “need input size.” That’s a misread. KEEP views live in the **test frame** and only need the **test input’s H×W** (which Π already gives). Training proofs use conjugation, not shape law, so you don’t need per-train sizes to define the views.

2. **They’re easy to define now, in test frame (no new data):**

   * **tile:** `V(i,j) = (i % Ht, j % Wt)`
   * **tile_alt_row_flip:** let `ti = i // Ht`; if `ti` odd, reflect within the tile: `V(i,j) = (i % Ht, (Wt-1) - (j % Wt))`, else `(i % Ht, j % Wt)`
   * **tile_alt_col_flip:** symmetric with `tj = j // Wt` parity
   * **tile_checkerboard_flip:** use `ti ^ tj` parity to decide whether to reflect row/col
   * **block_inverse(k):** `V(i,j) = (i // k, j // k)` (downsample read) — enumerate `k` from a small, deterministic set (e.g., divisors of `Ht` and `Wt` in ascending order, capped)
   * **offset(b,d):** `V(i,j) = (i - b, j - d)` — enumerate small |b|,|d| in a bounded lexicographic order; OOB → undefined (and thus reject for that class)

These are pure test-frame maps. Proofs still run per WO-08: `p_out → pose_inv → V → anchor_fwd → pose_fwd → p_in`, compare `Xin` vs `Yout`.

### Are we missing other KEEP families?

No. For ARC coverage, this catalogue is sufficient when combined with the residue/translate/D4 already implemented. If, during WO-10 (sieve), a class returns `missing_descriptor`, that’s your *constructive certificate* to add exactly one more descriptor. Until then, don’t bloat the set.

### What to correct in WO-08 right now

* Implement the three skipped families **now**, in `enumerate_keep_candidates`, using only `(Ht,Wt)` and bounded parameters, with the same deterministic order you already follow.
* Keep the **no-partial-KEEP** rule and the **first-witness receipts**. Reviewer should add a tiling golden (e.g., 00576224) so `tile_alt_*` is actually exercised.

### Why this matters

Skipping these breaks the “engineering = math” promise: some periodic/blow-up tasks can only be proven KEEP via a tile or block-inverse view. Since we can define them without extra context, they belong in WO-08, not later.

Bottom line: WO-08 was complete; the gap is in implementation. Add `tile*`, `block_inverse(k)`, `offset(b,d)` now, keep receipts, and let the sieve later tell us if anything else is truly missing.
